)]}'
{"version":3,"file":"/packages/templating.js","sources":["templating/templating.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sE;AACA,kB;AACA,c;;AAEA,yE;AACA,iE;AACA,qD;AACA,mC;AACA,2D;AACA,+B;AACA,4C;AACA,K;;AAEA,8C;AACA,qB;AACA,sB;AACA,E;;AAEA,qD;AACA,+D;AACA,e;AACA,oC;AACA,e;AACA,qC;AACA,8B;AACA,4B;AACA,kE;AACA,yC;AACA,Q;AACA,oC;AACA,4D;AACA,Q;AACA,iC;AACA,sC;AACA,iC;AACA,Q;AACA,iB;AACA,sB;AACA,qB;AACA,6B;AACA,+B;AACA,Q;AACA,oB;AACA,M;AACA,G;;AAEA,sC;;AAEA,2C;AACA,+C;AACA,6C;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;;AAEA,c;AACA,E;;AAEA,oC;AACA,oD;AACA,qB;AACA,2C;;AAEA,yD;AACA,E;;AAEA,iD;AACA,sB;AACA,sD;AACA,qB;AACA,2B;AACA,qC;AACA,wC;AACA,oD;AACA,6D;AACA,yB;AACA,oB;AACA,yD;AACA,mE;AACA,wC;AACA,mC;AACA,Q;AACA,uB;AACA,G;;AAEA,uC;AACA,E;;AAEA,kE;AACA,sB;AACA,wD;AACA,2B;;AAEA,+B;AACA,6E;AACA,4B;AACA,oE;;AAEA,6B;AACA,4C;AACA,qC;AACA,mC;AACA,gD;AACA,oE;AACA,yE;AACA,mE;AACA,kE;AACA,sE;AACA,mD;AACA,kE;AACA,O;;AAEA,iD;AACA,0C;AACA,S;AACA,O;AACA,G;;AAEA,0B;AACA,8B;;AAEA,yB;AACA,gC;AACA,yD;AACA,kC;AACA,O;AACA,G;;AAEA,0B;AACA,iC;AACA,yD;AACA,mC;AACA,O;AACA,G;;AAEA,2B;AACA,kC;AACA,yD;AACA,oC;AACA,O;AACA,G;;AAEA,c;AACA,E;;AAEA,sD;;AAEA,+C;AACA,qD;AACA,gB;AACA,oC;AACA,oC;AACA,gB;AACA,c;AACA,E;;AAEA,mE;AACA,gD;AACA,6B;AACA,+B;AACA,e;AACA,+B;;AAEA,c;AACA,E;;AAEA,6D;AACA,qD;AACA,0C;AACA,uH;AACA,uE;AACA,G;;AAEA,2E;AACA,qC;;AAEA,gC;AACA,c;AACA,E;;AAEA,wC;AACA,2B;AACA,E;;AAEA,yD;AACA,oB;AACA,6C;AACA,+C;AACA,6C;AACA,wC;AACA,0C;AACA,e;AACA,G;AACA,8D;;AAEA,gE;AACA,iE;AACA,+D;AACA,0C;AACA,qD;AACA,2C;AACA,mC;AACA,yC;AACA,W;AACA,4C;AACA,8C;AACA,wC;AACA,8B;AACA,E;AACA,kD;;;AAGA,oE;AACA,uC;AACA,6B;AACA,sC;AACA,8C;;AAEA,4B;AACA,E;;AAEA,qD;AACA,2C;AACA,sC;AACA,8C;AACA,iC;AACA,2E;;AAEA,oD;AACA,gB;AACA,M;AACA,E;;AAEA,qE;AACA,sE;AACA,qE;AACA,sB;AACA,uD;AACA,kE;AACA,sE;AACA,4C;AACA,oE;AACA,0D;AACA,kF;AACA,qD;AACA,wC;AACA,iE;;AAEA,wC;AACA,E;;AAEA,wB;AACA,8B;AACA,wC;AACA,iE;;AAEA,qB;AACA,mB;AACA,kB;AACA,E;;AAEA,4B","sourcesContent":["// Create an empty template object. Packages and apps add templates on\n// to this object.\nTemplate = {};\n\n// `Template` is not a function so this is not a real function prototype,\n// but it is used as the prototype of all `Template.foo` objects.\n// Naming a template \"prototype\" will cause an error.\nTemplate.prototype = (function () {\n  // IE 8 exposes function names in the enclosing scope, so\n  // use this IIFE to catch it.\n  return (function Template() {}).prototype;\n})();\n\nTemplate.prototype.helpers = function (dict) {\n  for (var k in dict)\n    this[k] = dict[k];\n};\n\nTemplate.__updateTemplateInstance = function (view) {\n  // Populate `view.templateInstance.{firstNode,lastNode,data}`\n  // on demand.\n  var tmpl = view._templateInstance;\n  if (! tmpl) {\n    tmpl = view._templateInstance = {\n      $: function (selector) {\n        if (! view.domrange)\n          throw new Error(\"Can't use $ on component with no DOM\");\n        return view.domrange.$(selector);\n      },\n      findAll: function (selector) {\n        return Array.prototype.slice.call(this.$(selector));\n      },\n      find: function (selector) {\n        var result = this.$(selector);\n        return result[0] || null;\n      },\n      data: null,\n      firstNode: null,\n      lastNode: null,\n      autorun: function (f) {\n        return view.autorun(f);\n      },\n      __view__: view\n    };\n  }\n\n  tmpl.data = Blaze.getViewData(view);\n\n  if (view.domrange && !view.isDestroyed) {\n    tmpl.firstNode = view.domrange.firstNode();\n    tmpl.lastNode = view.domrange.lastNode();\n  } else {\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\n    tmpl.firstNode = null;\n    tmpl.lastNode = null;\n  }\n\n  return tmpl;\n};\n\nUI._templateInstance = function () {\n  var templateView = Blaze.getCurrentTemplateView();\n  if (! templateView)\n    throw new Error(\"No current template\");\n\n  return Template.__updateTemplateInstance(templateView);\n};\n\nTemplate.prototype.events = function (eventMap) {\n  var template = this;\n  template.__eventMaps = (template.__eventMaps || []);\n  var eventMap2 = {};\n  for (var k in eventMap) {\n    eventMap2[k] = (function (k, v) {\n      return function (event/*, ...*/) {\n        var view = this; // passed by EventAugmenter\n        var data = Blaze.getElementData(event.currentTarget);\n        if (data == null)\n          data = {};\n        var args = Array.prototype.slice.call(arguments);\n        var tmplInstance = Template.__updateTemplateInstance(view);\n        args.splice(1, 0, tmplInstance);\n        return v.apply(data, args);\n      };\n    })(k, eventMap[k]);\n  }\n\n  template.__eventMaps.push(eventMap2);\n};\n\nTemplate.prototype.__makeView = function (contentFunc, elseFunc) {\n  var template = this;\n  var view = Blaze.View(this.__viewName, this.__render);\n  view.template = template;\n\n  view.templateContentBlock = (\n    contentFunc ? Template.__create__('(contentBlock)', contentFunc) : null);\n  view.templateElseBlock = (\n    elseFunc ? Template.__create__('(elseBlock)', elseFunc) : null);\n\n  if (template.__eventMaps ||\n      typeof template.events === 'object') {\n    view.onMaterialized(function () {\n      if (! template.__eventMaps &&\n          typeof template.events === \"object\") {\n        // Provide limited back-compat support for `.events = {...}`\n        // syntax.  Pass `template.events` to the original `.events(...)`\n        // function.  This code must run only once per template, in\n        // order to not bind the handlers more than once, which is\n        // ensured by the fact that we only do this when `__eventMaps`\n        // is falsy, and we cause it to be set now.\n        Template.prototype.events.call(template, template.events);\n      }\n\n      _.each(template.__eventMaps, function (m) {\n        Blaze._addEventMap(view, m, view);\n      });\n    });\n  }\n\n  if (template.__initView)\n    template.__initView(view);\n\n  if (template.created) {\n    view.onCreated(function () {\n      var inst = Template.__updateTemplateInstance(view);\n      template.created.call(inst);\n    });\n  }\n\n  if (template.rendered) {\n    view.onRendered(function () {\n      var inst = Template.__updateTemplateInstance(view);\n      template.rendered.call(inst);\n    });\n  }\n\n  if (template.destroyed) {\n    view.onDestroyed(function () {\n      var inst = Template.__updateTemplateInstance(view);\n      template.destroyed.call(inst);\n    });\n  }\n\n  return view;\n};\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nTemplate.__lookup__ = function (templateName) {\n  if (! _hasOwnProperty.call(Template, templateName))\n    return null;\n  var tmpl = Template[templateName];\n  if (Template.__isTemplate__(tmpl))\n    return tmpl;\n  return null;\n};\n\nTemplate.__create__ = function (viewName, templateFunc, initView) {\n  var tmpl = new Template.prototype.constructor;\n  tmpl.__viewName = viewName;\n  tmpl.__render = templateFunc;\n  if (initView)\n    tmpl.__initView = initView;\n\n  return tmpl;\n};\n\nTemplate.__define__ = function (templateName, templateFunc) {\n  if (_hasOwnProperty.call(Template, templateName)) {\n    if (Template[templateName].__makeView)\n      throw new Error(\"There are multiple templates named '\" + templateName + \"'. Each template needs a unique name.\");\n    throw new Error(\"This template name is reserved: \" + templateName);\n  }\n\n  var tmpl = Template.__create__('Template.' + templateName, templateFunc);\n  tmpl.__templateName = templateName;\n\n  Template[templateName] = tmpl;\n  return tmpl;\n};\n\nTemplate.__isTemplate__ = function (x) {\n  return x && x.__makeView;\n};\n\n// Define a template `Template.__body__` that renders its\n// `__contentParts`.\nTemplate.__define__('__body__', function () {\n  var parts = Template.__body__.__contentParts;\n  // enable lookup by setting `view.template`\n  for (var i = 0; i < parts.length; i++)\n    parts[i].template = Template.__body__;\n  return parts;\n});\nTemplate.__body__.__contentParts = []; // array of Blaze.Views\n\n// Define `Template.__body__.__instantiate()` as a function that\n// renders `Template.__body__` into `document.body`, at most once\n// (calling it a second time does nothing).  This function does\n// not use `this`, so you can safely call:\n// `Meteor.startup(Template.__body__.__instantiate)`.\nTemplate.__body__.__isInstantiated = false;\nvar instantiateBody = function () {\n  if (Template.__body__.__isInstantiated)\n    return;\n  Template.__body__.__isInstantiated = true;\n  var range = Blaze.render(Template.__body__);\n  Template.__body__.__view = range.view;\n  range.attach(document.body);\n};\nTemplate.__body__.__instantiate = instantiateBody;\n\n\n// Renders a template (eg `Template.foo`), returning a DOMRange. The\n// range will keep updating reactively.\nUI.render = function (tmpl) {\n  if (! Template.__isTemplate__(tmpl))\n    throw new Error(\"Template required here\");\n\n  return Blaze.render(tmpl);\n};\n\n// Same as `UI.render` with a data context passed in.\nUI.renderWithData = function (tmpl, data) {\n  if (! Template.__isTemplate__(tmpl))\n    throw new Error(\"Template required here\");\n  if (typeof data === 'function')\n    throw new Error(\"Data argument can't be a function\"); // XXX or can it?\n\n  return Blaze.render(Blaze.With(data, function () {\n    return tmpl;\n  }));\n};\n\n// The publicly documented API for inserting a DOMRange returned from\n// `UI.render` or `UI.renderWithData` into the DOM. If you then remove\n// `parentElement` using jQuery, all reactive updates on the rendered\n// template will stop.\nUI.insert = function (range, parentElement, nextNode) {\n  // parentElement must be a DOM node. in particular, can't be the\n  // result of a call to `$`. Can't check if `parentElement instanceof\n  // Node` since 'Node' is undefined in IE8.\n  if (! parentElement || typeof parentElement.nodeType !== 'number')\n    throw new Error(\"'parentElement' must be a DOM node\");\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\n    throw new Error(\"'nextNode' must be a DOM node\");\n  if (! range instanceof Blaze.DOMRange)\n    throw new Error(\"Expected template rendered with UI.render\");\n\n  range.attach(parentElement, nextNode);\n};\n\n// XXX test and document\nUI.remove = function (range) {\n  if (! range instanceof Blaze.DOMRange)\n    throw new Error(\"Expected template rendered with UI.render\");\n\n  if (range.attached)\n    range.detach();\n  range.destroy();\n};\n\nUI.body = Template.__body__;\n"]}